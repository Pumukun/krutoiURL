#ifndef EL_NODE_M_H
#define EL_NODE_M_H

using namespace std;

template<class K, class T>
class Node_m {
protected:
    //???????? ?????????? Node N; N.data = 10 ??????? ??????
    T data;
    K key;

    //?? ????? ??????? Node, ?? ????? ????? ??????? ?????????
    Node_m *left;
    Node_m *right;
    Node_m *parent;

    //??????????, ??????????? ??? ??????????? ??????? ??????
    int height;
public:
    //????????? ????? ?????????? ? ???????
    virtual void setData(T d) { data = d; }
    virtual void setKey(K k) { key = k; }

    virtual T getData() { return data; }
    virtual K getKey() { return key; };

    int getHeight() { return height; }

    virtual Node_m *getLeft() { return left; }
    virtual Node_m *getRight() { return right; }
    virtual Node_m *getParent() { return parent; }

    virtual void setLeft(Node_m *N) { left = N; }
    virtual void setRight(Node_m *N) { right = N; }
    virtual void setParent(Node_m *N) { parent = N; }

    //???????????. ????????????? ????????? ???????? ??? ??????????
    Node_m<K, T>(K k, T n) {
        data = n;
        key = k;
        left = right = parent = NULL;
        height = 1;
    }

    Node_m<K, T>(K k) {
        key = k;
        left = right = parent = NULL;
        height = 1;
    }

    Node_m<K, T>() {
        left = NULL;
        right = NULL;
        parent = NULL;
        height = 1;
    }


    virtual void print() {
        cout << "\n" << data << " " << key;
    }

    virtual void setHeight(int h) {
        height = h;
    }

    template<class K1, class T1>
    friend ostream &operator<<(ostream &stream, Node_m<K1, T1> &N);
};

template<class K1, class T1>
ostream &operator<<(ostream &stream, Node_m<K1, T1> &N) {
    stream << "\n{Key: " << N.key << ", data: " << N.data << "}, height: " << N.height;
    return stream;
}

#endif //EL_NODE_M_H
